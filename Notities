Pg 487 !
recursion (pg 502) - wnr string/list waarschijnkijk Helper!
-------------------------------------------------------------------------------------------------------------------
Feedbcack:
is_geldig_isbn13() doet exact één ding: → controleren of een ISBN correct is.

overzicht() doet exact één ding:→ de codes tellen per registratiegroep.

Geen functie doet twee taken door elkaar !!!!
Dat maakt de code veel gemakkelijker te begrijpen en te verbeteren.
-------------------------------------------------------------------------------------------------------------------------------
for getal, aantal in teller.items():
lijst = [woord.lower() for woord in woorden_splitsen(Filename)]

currentMinIndex = i + lijst[i:]/index(cuurentMin)

import sys
sys.exit()

lijst(range(10))
lijst.sort(reverse = True)
lijst = s.split()

s = s.replace(old, new)

.strip

import random
random.shuffle(list)
from random import randint
randint(0,9)

s.lower()

for ch in line:
    print(ch)

print(str(counts[i]) + (" time" if counts[i] == 1 else " times"))
print(word, counts, sep = '\t'

print(v, end=' ') #1 2 3 ...

v1, v2 = 2, 5

# Werking van modulo
# -----------------------------------------
# De vergelijking voor deling met rest:
#   a = b * q + r
# waarbij:
#   q = het gehele deel (integer quotient)
#   r = de rest (dit is wat a % b geeft)


# -----------------------------------------
# Modulo met negatieve getallen
# -----------------------------------------
# In Python heeft de uitkomst van a % b hetzelfde teken als b.

print("\nNegatieve getallen:")
print("-7 % 3  =", -7 % 3)    # 2
print("7 % -3  =", 7 % -3)    # -2


# -----------------------------------------
# Toepassingen van modulo
# -----------------------------------------

# 1. Checken of een getal even of oneven is
n = 8
if n % 2 == 0:
    print(f"\n{n} is even")
else:
    print(f"{n} is oneven")

# 2. Herhalende patronen (cycli)
i = 5
print("5 % 3 =", i % 3)       # 2 → cyclus 0,1,2

# 3. Afronden naar een veelvoud (hier: naar boven op 5)
import math
x = 17
boven_afronding = math.ceil(x / 5) * 5
print(f"\n17 naar boven afgerond op 5 = {boven_afronding}")

# 4. Controleren of een getal deelbaar is
x = 25
if x % 5 == 0:
    print(f"{x} is deelbaar door 5")
else:
    print(f"{x} is NIET deelbaar door 5")
---------------------------------------------------------------------------------------------------------------------------------
1. list.sort() — sorteert in-place

Dit past de lijst zelf aan.

lijst = [5, 2, 8, 1]
lijst.sort()
print(lijst)   # [1, 2, 5, 8]

Omgekeerd sorteren:
lijst.sort(reverse=True)

✅ 2. sorted() — maakt een nieuwe gesorteerde lijst
lijst = [5, 2, 8, 1]
gesorteerd = sorted(lijst)

print(gesorteerd)  # [1, 2, 5, 8]
------------------------------------------------------------------------------------------------------------------------------
Hier is de rangschikking van meest efficiënt naar minst efficiënt, gebaseerd op de gemiddelde tijdscomplexiteit (en ook typische prestaties in de praktijk):

✅ 1. Merge sort
Gemiddeld: O(n log n)
Slechtste geval: O(n log n)
Beste geval: O(n log n)
Opmerking: Altijd betrouwbaar, stabiel, maar gebruikt extra geheugen.

✅ 2. Quick sort
Gemiddeld: O(n log n)
Slechtste geval: O(n²) (maar zelden als pivot goed gekozen wordt)
Beste geval: O(n log n)
Opmerking: In de praktijk vaak het snelste door goede cache-prestaties en weinig overhead.
Dus merge sort en quick sort zijn duidelijk veel efficiënter dan insertion sort en bubble sort.

➖ 3. Insertion sort
Gemiddeld: O(n²)
Slechtste geval: O(n²)
Beste geval: O(n) (bijna gesorteerde lijst)
Opmerking: Veel beter dan bubble sort in de praktijk, heel efficiënt voor kleine of bijna gesorteerde lijsten.

❌ 4. Bubble sort
Gemiddeld: O(n²)
Slechtste geval: O(n²)
Beste geval: O(n) (als je de geoptimaliseerde versie gebruikt die stopt wanneer geen swaps meer gebeuren)
Opmerking: Algemeen de traagste sorteermethode, zelden gebruikt.
print(lijst)       # originele lijst blijft onveranderd
Ook met reverse=True:
gesorteerd = sorted(lijst, reverse=True)
