Pg 487 !
recursion (pg 502) - wnr string/list waarschijnkijk Helper!
-------------------------------------------------------------------------------------------------------------------
Feedbcack:
is_geldig_isbn13() doet exact één ding: → controleren of een ISBN correct is.
overzicht() doet exact één ding:→ de codes tellen per registratiegroep.
-----> Geen functie doet twee taken door elkaar !!!!
-------------------------------------------------------------------------------------------------------------------------------
for getal, aantal in teller.items():

lijst = [woord.lower() for woord in woorden_splitsen(Filename)]

while len(list) != 0:    (OF)    while not stack.isEmpty():
    ...pop()

currentMinIndex = i + lijst[i:].index(cuurentMin)

import sys
sys.exit()

lijst(range(10))

s = s.replace(old, new)

import random
random.shuffle(list)
from random import randint
randint(0,9)

s.lower()

for ch in line:
    print(ch)

print(str(counts[i]) + (" time" if counts[i] == 1 else " times"))
print(word, counts, sep = '\t')
---------------------------------------------------------------------------------------------------------------------------------
1. list.sort() — sorteert in-place
Dit past de lijst zelf aan.
lijst = [5, 2, 8, 1]
lijst.sort()
print(lijst)   # [1, 2, 5, 8]

Omgekeerd sorteren:
lijst.sort(reverse=True)

✅ 2. sorted() — maakt een nieuwe gesorteerde lijst
lijst = [5, 2, 8, 1]
gesorteerd = sorted(lijst)
print(gesorteerd)  # [1, 2, 5, 8]
------------------------------------------------------------------------------------------------------------------------------
VALKUILEN MET VARIABELEN

❌ Naam-shadowing
voorbeeld: telling = {} terwijl er een functie telling() bestaat

❌ Aliassets
a = b = set() → beide zijn dezelfde set
✔ a=set(); b=set()

❌ Verkeerde kopie
x = lst is alias
✔ x = lst[:]

VALKUILEN MET LIJSTEN

❌ list.remove(x) geeft None terug
→ nooit: y = lst.remove(x)

Gebruik altijd lijstkopie wanneer je verwijdert tijdens iteratie

list(range(10)) ipv lijst(range(...))

SETS EN DICTIONARIES

❌ set.add(set)
→ TypeError
✔ set.update(iterable)

.items() met haakjes
✔ for k,v in d.items():
❌ d.items

LOOPS & CONDITIES

❌ if 'A' in (vader and moeder)
→ werkt NIET zoals je denkt (kijkt enkel naar moeder)
✔ if 'A' in vader and 'A' in moeder

❌ Onterecht gebruik van elif
→ elif blokkeert andere mogelijkheden
✔ gebruik losse if indien meerdere opties mogen gelden

Scannen:
for ch in line:

Stack:
while not stack.isEmpty():

RECURSIE

❌ recursieve call zonder return
→ altijd: return helper(...)

❌ recursie die extra werk doet na de recursive call → geen tail recursion

Base case moet eenvoudig en correct zijn

SORTEREN

.sort() = in-place

sorted() = nieuwe lijst

lst.sort(reverse=True) bij aflopend

random.shuffle(lst)

STRINGS

.lower()

.strip()

.replace(old,new)

.split()

' '.join(lst)

BLOEDGROEP-SPECIFIEKE FOUTEN

(Jouw grootste cluster van fouten)

ABO fouten

❌ Samenvoegen van alle ouder-allelen en dan tellen
→ je moet alle combinaties één-alleltje-papa × één-alleltje-mama testen

❌ elif gebruiken waardoor je slechts één ABO-fenotype toevoegt

Geen onderscheid tussen genotype en fenotype

❌ 'AB' verkeerd behandeld via substring (“'A' in 'AB'”) i.p.v. via sets

Rhesus fouten

❌ Rhesus in dezelfde functie als ABO → chaos

❌ Rhesus bepaald via telling i.p.v. via combinaties

✔ Rh-fenotype = '+' als er minstens één '+' in {r1,r2} zit

Foutief logicapatroon

❌ 'A' in (vader and moeder)

❌ bloedgroep = mama.union(...) zonder te accumuleren

❌ geen rekening houden met combinatoriek → vooral fout bij AB × O

ALGORITMEN & EFFICIËNTIE

Insertion Sort < Quick Sort < Merge Sort

Altijd O(n²) vermijden tenzij onvermijdelijk

Geen onnodige nested loops

Gebruik sets/dicts voor O(1) lookup i.p.v. lists

DIJKSTRA / GRAAF-LOGICA

(Jij maakte deze fouten niet expliciet, maar dit is standaard-examenmateriaal → noodzakelijk.)

visited = set()

relaxatie:
✔ if d[u] + w < d[v]:

prioriteitsqueue:
✔ key = eerste element van tuple
→ (afstand, knoop)

early stop wanneer bestemming bereikt

PRINT / OUTPUT

print(v, end=' ')

print(word, count, sep='\t')

print(str(n) + (" time" if n==1 else " times"))
------------------------------------------------------------------------------

# Werking van modulo
# -----------------------------------------
# De vergelijking voor deling met rest:
#   a = b * q + r
# waarbij:
#   q = het gehele deel (integer quotient)
#   r = de rest (dit is wat a % b geeft)


# -----------------------------------------
# Modulo met negatieve getallen
# -----------------------------------------
# In Python heeft de uitkomst van a % b hetzelfde teken als b.

print("\nNegatieve getallen:")
print("-7 % 3  =", -7 % 3)    # 2
print("7 % -3  =", 7 % -3)    # -2


# -----------------------------------------
# Toepassingen van modulo
# -----------------------------------------

# 1. Checken of een getal even of oneven is
n = 8
if n % 2 == 0:
    print(f"\n{n} is even")
else:
    print(f"{n} is oneven")

# 2. Herhalende patronen (cycli)
i = 5
print("5 % 3 =", i % 3)       # 2 → cyclus 0,1,2

# 3. Afronden naar een veelvoud (hier: naar boven op 5)
import math
x = 17
boven_afronding = math.ceil(x / 5) * 5
print(f"\n17 naar boven afgerond op 5 = {boven_afronding}")

# 4. Controleren of een getal deelbaar is
x = 25
if x % 5 == 0:
    print(f"{x} is deelbaar door 5")
else:
    print(f"{x} is NIET deelbaar door 5")
